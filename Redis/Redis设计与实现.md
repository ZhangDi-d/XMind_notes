# Redis设计与实现

## 数据结构与对象

### 第2章 简单动态字符串

- 2.1 SDS的定义

	- free

		- 未使用空间

	- len

		- 字符串长度

	- buf

		- char类型的数组

- 2.2 SDS与C字符串的区别

	- 2.2.1 常数复杂度获取字符串长度

		- 确保了获取字符串长度的工作不会成为Redis的性能瓶颈

	- 2.2.2 杜绝缓冲区溢出

		- SDS在执行如拼接操作前都会检查分配的空间是否足够,不够会扩展空间

	- 2.2.3 减少修改字符串时带来的内存重分配次数

		- C语言中字符串的拼接可能会产生缓冲区溢出;如字符串截断,可能会产生内存泄漏

			- 所以执行这些操作都要进行内存重新分配

		- SDS通过未使用空间解除了字符串长度和底层数组长度之间的关联

			- 空间预分配

				- 用于优化SDS的字符串增长操作

					- 如果对SDS修改后，SDS长度（也即是len属性的值）小于1MB，那么程序分配和len属性同样大小的未使用空间，这时SDS len属性的值将和free属性的值相同,如修改后len为13字节,buf实际长度= 13+13+1 = 27 字节
					- 如果对SDS进行修改之后，SDS的长度将大于等于1MB，那么程序会分配1MB的未使用空间. 如修改后，SDS的len变成30MB，那么程序会分配1MB的未使用空间，buf数组实际长度=30MB+1MB+1byte。

			- 惰性空间释放

				- 用于优化SDS的字符串缩短操作

					- 如sdstrim("XXXYYY123","X") //从字符串中移除X, SDS并不会释放3字节,而是将3字节作为未使用空间保留在SDS中. 后续 sdscat操作未使用空间就可以派上用场

	- 2.2.4 二进制安全

		- C字符串中的字符编码严格,并且除末尾外,不能包含空字符

			- 这些限制使得C字符串只能保存文本数据,而不能保存像图片、视频、压缩文件这样的二进制数据。

		- SDS的API都是二进制安全的（binary-safe）

			- SDS来保存之前提到的特殊数据格式就没有任何问题,因为SDS使用len属性的值而不是空字符来判断字符串是否结束

				- SDS可以保存任意格式的二进制数据

	- 2.2.5 兼容部分C字符串函数

		- 通过遵循C字符串以空字符结尾的惯例，SDS可以在有需要时重用＜string.h＞函数库

### 第3章 链表

- 引言 : C语言并没有内置这种数据结构，所以Redis构建了自己的链表实现.Redis中列表的底层结构就是链表(双端链表) , 发布与订阅、慢查询、监视器等功能也用到了链表
- 3.1 链表和链表节点的实现

	- Redis的链表实现

		- 链表节点

			- 用adlist.h/listNode表示

		- 用多个listNode结构就可以组成链表，但使用adlist.h/list来持有链表,操作会更方便

			- list结构

		- 由一个list结构和三个listNode结构组成的链表

			- 

	- Redis的链表特点

		- 双端：链表节点带有prev和next指针,获取前后节点时间复杂度为O(1)
		- 无环：表头节点的prev指针和表尾节点的next指针都指向NULL，对链表的访问以NULL为终点
		- 带表头指针和表尾指针：通过list结构的head指针和tail指针，程序获取链表的表头节点和表尾节点的复杂度为O（1）
		- 带链表长度计数器：程序使用list结构的len属性计数，获取链表中节点数量的复杂度为O（1）
		- 多态: 链表可以用于保存各种不同类型的值

